---
title: "Classifying Retirement Plan Financial Adequacy Using Form 5500 Data"
subtitle: "Exploratory Data Analysis and Feature Engineering"
author: "Donnie Minnick, Statistical Learning - Fall A 2025"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
---

This analysis leverages the following R packages: `dplyr`, `lubridate` and `tidyr` for data manipulation, `knitr` for report formatting, and `ggplot2` and `ggridges` for visualization.

```{r, load_libraries echo = FALSE, message = FALSE}
library("dplyr")
library("ggplot2")
library("ggridges")
library("knitr")
library("lubridate")
library("tidyr")
```
Load Form 5500 data.

```{r load_data}
plans <- readRDS("../data/plans.rds")
```

# Missing Data

Generate a report to check for missing values in the data at both the column and row level.

```{r missing_data}
# Create column level summary.

col_missing <- plans %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(cols = everything(),
               names_to = "Variable",
               values_to = "Missing_Count") %>%
  mutate(Missing_Percent = Missing_Count / nrow(plans) * 100)

# Create row level summary.

row_missing <- tibble(Variable = "Rows Any Missing",
                      Missing_Count = sum(!complete.cases(plans)),
                      Missing_Percent = sum(!complete.cases(plans)) / nrow(plans) * 100)

# Combine summaries.

missing_report <- bind_rows(col_missing, row_missing)

kable(missing_report,
      col.names = c("Variable", "Missing Count", "Missing Percent"),
      caption = "Missing Data",
      format.args = list(big.mark = ","),
      align = c("l", "r", "r"))
```

# Plan Effective Date (PLAN_EFF_DATE)

Plan effective date marks the official inception of a retirement plan, i.e. the date it became active and enforceable under its governing provisions. This date anchors the plan’s life cycle, serving as a reference point for regulatory applicability, sponsor tenure, and cohort benchmarking.

From an analytic perspective, plan effective date enables several valuable transformations.  Calculating plan age from this field allows for stratification by maturity, which is useful when assessing financial readiness across vintage cohorts.  Plans initiated in different eras may reflect distinct design philosophies, contribution behaviors, or participant engagement patterns. 

Grouping by plan effective date also supports fairness overlays, helping identify whether newer plans offer comparable adequacy and access relative to legacy plans.

In benchmarking workflows, plan effective date can be paired with business code (BUSINESS_CODE) to explore sector-specific adoption trends.

```{r summary_plan_effective_date}
summary_plan_effective_date <- plans %>%
  mutate(PLAN_EFF_YEAR = as.character(year(PLAN_EFF_DATE))) %>%
  group_by(PLAN_EFF_YEAR) %>%
  arrange(PLAN_EFF_YEAR) %>%
  summarise(entries = n(), .groups = "drop") %>%
  mutate(percent = round(entries / sum(entries), 2))

kable(summary_plan_effective_date,
      col.names = c("Plan Effective Year", "Entries", "Percent"),
      caption = "Summary Plan Effective Year",
      format.args = list(big.mark = ","),
      align = c("l", "r", "r"))
```

Plot plans by plan effective year.

```{r plot_summary_plan_effective_date}
ggplot(summary_plan_effective_date, aes(x = as.integer(PLAN_EFF_YEAR), y = entries)) +
  geom_col(fill = "steelblue", color = "white") +
  # geom_text(aes(label = paste0(scales::comma(entries), "\n", round(percent * 100, 0), "%")),
  #           vjust = -0.3, size = 3.0) +
  labs(title = "Distribution of Plan Effective Dates By Year",
       x = "Year",
       y = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        plot.title = element_text(size = 14, face = "bold")) +
  expand_limits(y = max(summary_plan_effective_date$entries) * 1.2)
```

This distribution tells a compelling story about the evolution of retirement plan adoption in the U.S. The gradual rise from the 1940s through the 1970s reflects the early institutionalization of employer-sponsored plans, likely driven by post-war economic expansion and the formalization of pension structures.

The sharp uptick in the late 1970s through the 1990s coincides with major policy shifts, most notably the passage of ERISA in 1974 and the rise of defined contribution plans like 401(k)s in the early 1980s. This era marks a surge in plan formation, especially among small and mid-sized employers responding to new regulatory clarity and tax incentives.

The peak in the late 1990s to early 2000s suggests a saturation point, after which the decline reflects consolidation of plans or sponsor exits, a shift toward pooled or multi-employer arrangements, and market volatility post-2008 influencing plan formation.

From a benchmarking or fairness audit perspective, this distribution is useful for stratifying plans by vintage. Plans initiated in different eras may have distinct design philosophies, contribution behaviors, or participant engagement patterns. A plan vintage feature (e.g. pre-1980, 1980–1999, post-2000) can help assess adequacy or access across cohorts. Pairing this variable with business code (BUSINESS_CODE) would allow sector-specific diagnostics, e.g. whether certain industries adopted plans earlier or more consistently.

Create a plan vintage group variable.

```{r create_plan_vintage_group}
plans <- plans %>%
  mutate(
    PLAN_EFF_YEAR = year(PLAN_EFF_DATE),
    PLAN_VINTAGE_GROUP = case_when(
      PLAN_EFF_YEAR < 1980 ~ "Legacy (Pre-1980)",
      PLAN_EFF_YEAR >= 1980 & PLAN_EFF_YEAR <= 1999 ~ "Expansion (1980–1999)",
      PLAN_EFF_YEAR >= 2000 & PLAN_EFF_YEAR <= 2009 ~ "Modern (2000–2009)",
      PLAN_EFF_YEAR >= 2010 & PLAN_EFF_YEAR <= 2019 ~ "Post-Crisis (2010–2019)",
      PLAN_EFF_YEAR >= 2020 ~ "Recent (2020+)"),
    PLAN_VINTAGE_GROUP = factor(PLAN_VINTAGE_GROUP,levels = c("Legacy (Pre-1980)",
                                                              "Expansion (1980–1999)",
                                                              "Modern (2000–2009)",
                                                              "Post-Crisis (2010–2019)",
                                                              "Recent (2020+)"),
                                ordered = TRUE))
```

Plot plans by plan vintage group.

```{r plot_summary_plan_vintage_group}
summary_plan_vintage_group <- plans %>%
  group_by(PLAN_VINTAGE_GROUP) %>%
  summarise(entries = n(), .groups = "drop") %>%
  mutate(percent = round(entries / sum(entries), 2))

ggplot(summary_plan_vintage_group, aes(x = PLAN_VINTAGE_GROUP, y = entries)) +
  geom_col(fill = "steelblue", color = "white") +
  geom_text(aes(label = paste0(scales::comma(entries), "\n", round(percent * 100, 0), "%")),
            vjust = -0.3, size = 3.0) +
  labs(title = "Distribution of Plans By Plan Vintage Group",
       x = "Year",
       y = "Group") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        plot.title = element_text(size = 14, face = "bold")) +
  expand_limits(y = max(summary_plan_vintage_group$entries) * 1.2)
```

Given this distribution, where plan counts rise sharply in the Expansion era and taper off in more recent vintages, we are dealing with a nonlinear, asymmetric pattern that’s not well captured by a simple linear term.

A spline would allow flexible modeling of nonlinear relationships without forcing global curvature.  I can place knots at meaningful breakpoints, e.g. 1980, 2000, 2010, using plan effective year to reflect policy or behavioral shifts. This would be easy to explain in stakeholder terms: plan creation changes around key regulatory eras.

When performing logistic regression, splines allow the model to capture non-linearity by breaking the predictor into segments and fitting piece-wise polynomials.

Random forests don’t need splines to model non-linearity. They’re built to handle it through recursive splits. However, engineering spline-based features can make comparisons cleaner and diagnostics more stakeholder-friendly.

# Sponsor state (SPONS_DFE_MAIL_US_STATE)

The variable sponsor state (SPONS_DFE_MAIL_US_STATE) refers to the U.S. state listed in the mailing address of the plan sponsor or Direct Filing Entity (DFE) on Form 5500. It captures the geographic location of the sponsor’s administrative contact, not necessarily the location of plan participants or operations.

This field is useful for regional benchmarking and comparing plan characteristics or adequacy across states, regulatory overlays, such as aligning with state-specific compliance or fiduciary rules, and geographic stratification.

Summarize plans by sponsor state.

```{r summary_sponsor_state}
summary_sponsor_state <- plans %>%
  group_by(SPONS_DFE_MAIL_US_STATE) %>%
  summarise(entries = n(), .groups = "drop") %>%
  arrange(desc(entries)) %>%
  mutate(percent = round(entries / sum(entries), 2))

kable(summary_sponsor_state,
      col.names = c("Sponsor State", "Entries", "Percent"),
      caption = "Summary Sponsor State",
      format.args = list(big.mark = ","),
      align = c("l", "r", "r"))
```

Plot plans by state.

```{r plot_summary_sponsor_state}
ggplot(summary_sponsor_state, aes(x = forcats::fct_reorder(SPONS_DFE_MAIL_US_STATE, 
                                                           entries, 
                                                           .desc = TRUE), y = entries)) +
  geom_col(fill = "steelblue", color = "white") +
  # geom_text(aes(label = paste0(scales::comma(entries), "\n", round(percent * 100, 0), "%")),
  #           vjust = -0.3, size = 3.0) +
  labs(title = "Distribution of Plans By Sponsor State",
       x = "Year",
       y = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5),
        plot.title = element_text(size = 14, face = "bold")) +
  expand_limits(y = max(summary_sponsor_state$entries) * 1.2)
```

This distribution aligns closely with population density and economic concentration. States like California, Texas, New York, and Florida tend to dominate in plan counts because they host a large number of employers, especially in sectors with high plan adoption rates (e.g. finance, tech, healthcare).

High counts also reflect regional hubs of plan sponsors, especially in metro areas with strong retirement plan infrastructure.  States with proactive retirement initiatives, e.g. CalSavers in California, may show elevated plan formation or reporting.

I can potentially combine sponsor state with business code (BUSINESS_CODE) to see which industries drive plan formation in each region.

# Business Code and Industry Title (BUSINESS_CODE, INDUSTRY_TITLE)

Business code (BUSINESS_CODE) refers to the six-digit code used to classify the primary business activity of the plan sponsor, based on the North American Industry Classification System (NAICS). It identifies the economic sector in which the sponsoring organization operates—such as manufacturing, healthcare, finance, or education.  Industry title (INDUSTRY_TITLE) is the human-readable label associated with that code.

```{r summary_industry_title}
summary_industry_title <- plans %>%
  group_by(INDUSTRY_TITLE) %>%
  summarise(entries = n(), .groups = "drop") %>%
  arrange(desc(entries)) %>%
  mutate(percent = round(entries / sum(entries), 2))

kable(head(summary_industry_title, 20),
      col.names = c("Industry", "Entries", "Percent"),
      caption = "Summary Industry - Top 20 Entries",
      format.args = list(big.mark = ","),
      align = c("l", "r", "r"))
```

Representation at the detailed industry title level is sparse. Most individual NAICS-derived titles contribute less than 0.03% of total plan filings, which suggests that modeling or benchmarking at this granularity may be noisy or unstable.  A few industries dominate plan filings, while most contribute marginally. The detailed industry title field has many levels, but low support per level. Using these titles directly in models could lead to poor generalization unless grouped.

Collapse to broader categories using existing business code structure and group industries into sectors. This reduces cardinality and improves interpretability.

```{r create_sectors}
business_codes <- readRDS("../data/business_codes.rds")

business_codes <- business_codes %>%
  rename(SECTOR_CODE = BUSINESS_CODE,
         SECTOR_TITLE = INDUSTRY_TITLE)

plans <- plans %>%
  mutate(SECTOR_CODE = as.integer(substr(BUSINESS_CODE, 1, 2)) * 10000)

plans <- left_join(plans, business_codes, by = "SECTOR_CODE")

summary_sector_title <- plans %>%
  group_by(SECTOR_TITLE) %>%
  summarise(entries = n(), .groups = "drop") %>%
  arrange(desc(entries)) %>%
  mutate(percent = round(entries / sum(entries), 2))

kable(summary_sector_title,
      col.names = c("Sector", "Entries", "Percent"),
      caption = "Summary Sector",
      format.args = list(big.mark = ","),
      align = c("l", "r", "r"))
```

Plot by sector title.

```{r plot_sectors}
ggplot(summary_sector_title, aes(x = forcats::fct_reorder(stringr::str_trunc(SECTOR_TITLE, width = 20), entries, .desc = TRUE), y = entries)) +
  geom_col(fill = "steelblue", color = "white") +
  geom_text(aes(label = paste0(scales::comma(entries), "\n", round(percent * 100, 0), "%")),
            vjust = -0.3, size = 3.0) +
  labs(title = "Distribution of Plans By Sector",
       x = "Sector",
       y = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5),
        plot.title = element_text(size = 14, face = "bold")) +
  expand_limits(y = max(summary_sector_title$entries) * 1.2)
```

This plot reveals an imbalance in plan availability across sectors. The top few, e.g Manufacturing, Professional Services, and Healthcare, dominate the landscape, accounting for over half of all plans. 

Saturated sectors like Manufacturing and Professional Services are likely have legacy plan structures and strong compliance cultures.

Healthcare shows high plan counts, possibly due to large institutional employers and unionized workforces.

Under-served sectors, such as Accommodation and Food Services, Arts and Entertainment, and Agriculture show very low plan counts despite employing millions. These sectors often have high turnover, part-time labor, or small businesses, all factors that historically correlate with low plan sponsorship.

In terms of predictors, I can leverage this insight by engineering two features: a plan penetration rate of plans per 1,000 employers or per 10,000 workers in each sector, and a sector adequacy flag that compares assets-per-participant or contribution ratios across sectors.  The first captures structural access to retirement plans across sectors.  I expect it will be a strong signal for access disparity and potential classification into “adequate” versus "inadequate” groups.

Binary or ordinal indicator based on sector-level averages of assets-per-participant or contribution ratios captures financial sufficiency of plans within each sector.  It may highlight whether certain industries consistently offer more robust retirement benefits.

Together, these features allow models to account for both who has access and how well those plans perform, making your adequacy classification more equitable and diagnostically transparent.

Implement plan penetration rate.

```{r}
total_participants_all <- sum(plans$TOT_ACTIVE_PARTCP_CNT)

sector_participant_share <- plans %>%
  group_by(SECTOR_TITLE) %>%
  summarise(total_participants = sum(TOT_ACTIVE_PARTCP_CNT, na.rm = TRUE)) %>%
  mutate(percent_participants = round(total_participants / total_participants_all, 4)) %>%
  arrange(desc(percent_participants))

kable(sector_participant_share,
      col.names = c("Sector", "Participants", "Percent"),
      caption = "Summary Sector",
      format.args = list(big.mark = ","),
      align = c("l", "r", "r"))
```



```{r}
ggplot(sector_participant_share, aes(x = forcats::fct_reorder(stringr::str_trunc(SECTOR_TITLE, width = 20), 
                                                              total_participants, .desc = TRUE), 
                                     y = total_participants)) +
  geom_col(fill = "steelblue", color = "white") +
  # geom_text(aes(label = paste0(scales::comma(total_participants), "\n", round(percent_participants * 100, 0), "%")),
  #           vjust = -0.3, size = 3.0) +
  labs(title = "Distribution of Participants by Sector",
       x = "Sector",
       y = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5),
        plot.title = element_text(size = 14, face = "bold")) +
  expand_limits(y = max(sector_participant_share$total_participants) * 1.2)
```

This distribution reveals a disparity in coverage. High-coverage sectors like Manufacturing (18.4%), Healthcare (16.5%), and Retail (13.3%) dominate participant coverage. They most likely host large employers with institutional plans, unionized workforces, or strong compliance cultures. Their plans may be more standardized, with higher assets-per-participant and broader eligibility.

Low-coverage sectors like Agriculture (0.5%), Mining (0.6%), Education (0.7%), and Public Administration (0.06%) are severely underrepresented. They may face structural barriers: seasonal labor, fragmented employment, or reliance on alternative retirement systems, e.g. public pensions are not captured in Form 5500.

Calculate participant share by sector.

```{r}
sector_participant_share <- sector_participant_share %>%
  select(-total_participants) %>%
  rename(SECTOR_PARTICIPANT_SHARE = percent_participants)

plans <- left_join(plans, sector_participant_share, by = "SECTOR_TITLE")
```

# Total Plan Assets (TOT_ASSETS_BOY_AMT, TOT_ASSETS_EOY_AMT)

These variables represent the total value of all plan assets held by the plan at the start and end of the plan year.

```{r}
summary_plan_assets <- plans %>%
  group_by(SECTOR_TITLE) %>%
  summarise(total_assets_boy = sum(TOT_ASSETS_BOY_AMT),
            total_assets_eoy = sum(TOT_ASSETS_EOY_AMT),
            .groups = "drop")

kable(summary_plan_assets,
      col.names = c("Sector", "BOY Assets", "EOY Assets"),
      caption = "BOY and EOY Total Plan Assets By Sector",
      format.args = list(big.mark = ","),
      align = c("l", "r", "r"))
```

Plot assets by sector.

```{r}
assets_long <- summary_plan_assets %>%
  pivot_longer(cols = c(total_assets_boy, total_assets_eoy),
               names_to = "Asset_Type",
               values_to = "Asset_Value")

ggplot(assets_long, aes(x = reorder(stringr::str_trunc(SECTOR_TITLE, width = 20), -Asset_Value), y = Asset_Value / 1e9, fill = Asset_Type)) +
  geom_bar(stat = "identity", position = "dodge") +
    scale_fill_manual(values = c("total_assets_boy" = "steelblue", "total_assets_eoy" = "lightsteelblue"),
                      labels = c("total_assets_boy" = "Beginning of Year", "total_assets_eoy" = "End of Year")) +
  labs(title = "BOY and EOY Total Plan Assets by Sector",
       x = "Sector",
       y = "Assets (Billions USD)",
       fill = "Asset Type") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5),
        plot.title = element_text(size = 14, face = "bold"))
```

Asset growth over the course of the year is consistent across all sectors.

Create a growth rate and assets per participant for each plan.

```{r}
plans <- plans %>%
  mutate(
    TOT_ASSETS_GROWTH_RATE = case_when(
      TOT_ASSETS_BOY_AMT == 0 & TOT_ASSETS_EOY_AMT > 0 ~ 1.0000,
      TOT_ASSETS_BOY_AMT == 0 & TOT_ASSETS_EOY_AMT == 0 ~ 0,
      TOT_ASSETS_BOY_AMT != 0 ~ round((TOT_ASSETS_EOY_AMT - TOT_ASSETS_BOY_AMT) / TOT_ASSETS_BOY_AMT, 4),
      TRUE ~ NA_real_))
```

Produce a density plot to show the distribution of asset growth rates.

One plan with an asset growth rate of 84% is a serious outlier and distorting the overall distribution.  I exclude the outlier in the following plot.

```{r}
ggplot(plans %>% filter(TOT_ASSETS_GROWTH_RATE <= 10), aes(x = TOT_ASSETS_GROWTH_RATE)) +
  geom_density(fill = "steelblue", alpha = 0.6) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray40") +
  labs(title = "Density of Asset Growth Rates (Excluding Outlier)",
       x = "Growth Rate",
       y = "Density") +
  theme_minimal()
```

Most plans have modest or stagnant asset growth, likely reflecting market conditions, contribution behavior, or plan maturity.

The right skew suggests a subset of plans with strong growth, possibly due to rollovers, mergers, or aggressive investment strategies.

The sharp peak near zero could indicate structural inertia, plans that are underfunded, inactive, or not receiving contributions.

Create a ridgeline plot by sector.

```{r}
plans %>%
  filter(TOT_ASSETS_GROWTH_RATE <= 10) %>%
  ggplot(aes(x = TOT_ASSETS_GROWTH_RATE, y = stringr::str_trunc(SECTOR_TITLE, width = 20))) +
  geom_density_ridges(bandwidth = 0.05, fill = "steelblue", alpha = 0.6) +
  labs(title = "Asset Growth Rate by Sector (≤ 10)",
       x = "Growth Rate",
       y = "Sector") +
  theme_minimal()
```

Most sectors cluster near zero; the sharp density around zero suggests widespread stagnation or minimal growth, possibly reflecting low contributions, market flatness, or plan maturity.

Right-skewed tails in sectors like Finance and Insurance, Real Estate, and Professional Services hint at pockets of aggressive growth, likely driven by rollovers, mergers, or high-income participant behavior.

Public sector plans (e.g. Educational Services, Health Care, Public Administration) show tighter distributions, possibly due to more regulated funding structures or consistent employer contributions.

Volatile sectors like Construction, Arts, and Accommodation show broader spread, likely reflecting economic sensitivity and participant turnover.




```{r}
plans <- plans %>%
  mutate(
    DENOMINATOR = case_when(
      PARTCP_ACCOUNT_BAL_CNT > 0 ~ PARTCP_ACCOUNT_BAL_CNT,
      TOT_ACTIVE_PARTCP_CNT > 0 ~ TOT_ACTIVE_PARTCP_CNT,
      TOT_ACT_PARTCP_BOY_CNT > 0 ~ TOT_ACT_PARTCP_BOY_CNT,
      TRUE ~ NA_real_
    ),
    ASSETS_PER_PARTCP = round(TOT_ASSETS_EOY_AMT / DENOMINATOR, 0)
  ) %>% select(-DENOMINATOR)
```

Plot assets per participant

```{r}
ggplot(plans, aes(x = ASSETS_PER_PARTCP)) +
  geom_density(fill = "steelblue", alpha = 0.6) +
  geom_vline(xintercept = median(plans$ASSETS_PER_PARTCP, na.rm = TRUE), 
             linetype = "dashed", color = "darkred") +
  labs(title = "Density of Assets per Participant",
       x = "Assets per Participant (USD)",
       y = "Density") +
  theme_minimal()
```

That sharp peak near the lower end, followed by a long right tail, suggests most plans cluster below $100K per participant, but a few are pulling the average upward with much higher balances.

Plot the log-transformed distribution to reveal structure in the lower range.

```{r}
ggplot(plans, aes(x = log1p(ASSETS_PER_PARTCP))) +
  geom_density(fill = "steelblue", alpha = 0.6) +
  labs(title = "Log-Scaled Density of Assets per Participant",
       x = "log(Assets + 1)",
       y = "Density") +
  theme_minimal()
```

That peak around 10 corresponds to roughly $22,000–$25,000 per participant, which is a much more grounded estimate of typical adequacy than the inflated mean near $100K.

Most plans are far below the mean: The log transformation exposes that the bulk of plans cluster in the $10K–$30K range, not near six figures.

Long tail still exists: But now it’s visually compressed, allowing us to focus on the core distribution.

Create adequacy tier labels.

```{r}
plans <- plans %>%
  mutate(
    ADEQUACY_TIER = case_when(
      ASSETS_PER_PARTCP < 5000 ~ "< $5K",
      ASSETS_PER_PARTCP >= 5000 & ASSETS_PER_PARTCP < 25000 ~ "$5K–$25K",
      ASSETS_PER_PARTCP >= 25000 & ASSETS_PER_PARTCP < 50000 ~ "$25K–$50K",
      ASSETS_PER_PARTCP >= 50000 & ASSETS_PER_PARTCP < 100000 ~ "$50K–$100K",
      ASSETS_PER_PARTCP >= 100000 ~ "> $100K",
      TRUE ~ NA_character_),
    ADEQUACY_TIER = factor(ADEQUACY_TIER,
                           levels = c("< $5K", "$5K–$25K", "$25K–$50K", "$50K–$100K", "> $100K"),
                           ordered = TRUE))
```

Boxplot by tier.

```{r}
ggplot(plans, aes(x = ASSETS_PER_PARTCP, fill = ADEQUACY_TIER)) +
  geom_density(alpha = 0.6) +
  facet_wrap(~ ADEQUACY_TIER, scales = "free") +
  scale_fill_manual(values = c("firebrick", "gold", "skyblue", "steelblue", "forestgreen")) +
  labs(title = "Density of Assets per Participant by Adequacy Tier",
       x = "Assets per Participant (USD)",
       y = "Density") +
  theme_minimal() +
  theme(legend.position = "none")
```

